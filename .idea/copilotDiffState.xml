<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/BE/sale-tech-web/ENVIRONMENT_SETUP.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/BE/sale-tech-web/ENVIRONMENT_SETUP.md" />
              <option name="updatedContent" value="# Hướng dẫn cấu hình Environment Variables cho Spring Boot&#10;&#10;## ⚠️ Lưu ý quan trọng&#10;Hiện tại bạn có **CẢ 2 FILE** cấu hình:&#10;- `application.properties` (file cũ)&#10;- `application.yml` (file mới - đã được cấu hình đầy đủ)&#10;&#10;**Khuyến nghị:** Xóa hoặc đổi tên file `application.properties` để tránh xung đột.&#10;&#10;##  Các cách chạy ứng dụng&#10;&#10;### **CÁCH 1: Sử dụng IntelliJ IDEA Environment Variables (ĐƠN GIẢN NHẤT)**&#10;&#10;Đây là cách bạn đã sử dụng trước đó và **ĐANG HOẠT ĐỘNG TốT**.&#10;&#10;#### Các bước:&#10;1. Mở **Run &gt; Edit Configurations...** (hoặc nhấn Alt+Shift+F10)&#10;2. Chọn `SaleTechWebApplication`&#10;3. Trong tab **Environment**, tìm field **Environment variables**&#10;4. Nhấn nút **...** để mở hộp thoại&#10;5. Thêm các biến sau (copy từ file `.env`):&#10;   ```&#10;   DB_URL=jdbc:postgresql://localhost:5432/salestechweb&#10;   DB_USER=postgres&#10;   DB_PASS=Qazedc123S&#10;   JWT_SECRET=Y29tRXhhbXBsZVNlY3JldEtleTIwMjUyMjAzMTY&#10;   JWT_EXPIRATION=86400000&#10;   ```&#10;6. Nhấn **OK** và **Apply**&#10;7. Chạy ứng dụng bình thường&#10;&#10;**✅ Ưu điểm:**&#10;- Đơn giản, dễ cấu hình&#10;- Không cần thêm code hay dependency&#10;- An toàn (không commit credentials lên Git)&#10;&#10;**❌ Nhược điểm:**&#10;- Phải cấu hình lại mỗi khi clone project mới&#10;- Chỉ hoạt động với IntelliJ IDEA&#10;&#10;---&#10;&#10;### **CÁCH 2: Sử dụng Spring Boot DevTools + .env file**&#10;&#10;Với cấu hình mới, bạn có thể sử dụng file `.env` trực tiếp.&#10;&#10;#### Bước 1: Cài đặt EnvFile Plugin (Optional - giúp load .env)&#10;1. Vào **File &gt; Settings &gt; Plugins**&#10;2. Tìm &quot;EnvFile&quot;&#10;3. Cài đặt plugin&#10;&#10;#### Bước 2: Cấu hình Run Configuration&#10;1. Mở **Run &gt; Edit Configurations...**&#10;2. Chọn `SaleTechWebApplication`&#10;3. Nếu có plugin EnvFile:&#10;   - Chọn tab **EnvFile**&#10;   - Nhấn **+** và chọn file `.env`&#10;   - Tick vào &quot;Enable EnvFile&quot;&#10;4. Nhấn **Apply** và chạy&#10;&#10;**✅ Ưu điểm:**&#10;- Tự động load từ file `.env`&#10;- Dễ chia sẻ cấu hình trong team&#10;- Có thể có nhiều file `.env.dev`, `.env.prod`&#10;&#10;**❌ Nhược điểm:**&#10;- Cần cài plugin&#10;- Cần cấu hình thêm&#10;&#10;---&#10;&#10;### **CÁCH 3: Sử dụng System Environment Variables (CHO PRODUCTION)**&#10;&#10;#### Trên Windows:&#10;1. Mở **System Properties &gt; Environment Variables**&#10;2. Thêm các biến vào **User variables** hoặc **System variables**&#10;3. Khởi động lại IntelliJ IDEA&#10;4. Chạy ứng dụng&#10;&#10;#### Hoặc qua PowerShell:&#10;```powershell&#10;$env:DB_URL=&quot;jdbc:postgresql://localhost:5432/salestechweb&quot;&#10;$env:DB_USER=&quot;postgres&quot;&#10;$env:DB_PASS=&quot;Qazedc123S&quot;&#10;$env:JWT_SECRET=&quot;Y29tRXhhbXBsZVNlY3JldEtleTIwMjUyMjAzMTY&quot;&#10;$env:JWT_EXPIRATION=&quot;86400000&quot;&#10;```&#10;&#10;**✅ Ưu điểm:**&#10;- Phù hợp cho production/staging&#10;- Không cần cấu hình lại&#10;&#10;**❌ Nhược điểm:**&#10;- Khó quản lý nhiều project&#10;- Cần restart IDE/terminal&#10;&#10;---&#10;&#10;### **CÁCH 4: Sử dụng Maven Exec Plugin với .env**&#10;&#10;Chạy từ terminal:&#10;```powershell&#10;cd E:\Technology-Sales-Website\BE\sale-tech-web&#10;&#10;# Load .env và chạy&#10;Get-Content .env | ForEach-Object {&#10;    if ($_ -match '^([^=]+)=(.*)$') {&#10;        $name = $matches[1]&#10;        $value = $matches[2]&#10;        [Environment]::SetEnvironmentVariable($name, $value, 'Process')&#10;    }&#10;}&#10;&#10;mvn spring-boot:run&#10;```&#10;&#10;---&#10;&#10;##  KHUYẾN NGHỊ CỦA TÔI&#10;&#10;**Tiếp tục sử dụng CÁCH 1** (IntelliJ Environment Variables) vì:&#10;1. ✅ Bạn đã quen và nó đang hoạt động tốt&#10;2. ✅ Đơn giản nhất, không cần cấu hình thêm&#10;3. ✅ An toàn, không lo lộ credentials&#10;4. ✅ Linh hoạt, dễ thay đổi giá trị khi test&#10;&#10;**Chỉ cần:**&#10;- Giữ file `.env` để làm template (đổi tên thành `.env.example`)&#10;- Lưu cấu hình Environment Variables trong IntelliJ IDEA&#10;- Backup lại cấu hình để khi clone project mới chỉ việc copy paste&#10;&#10;---&#10;&#10;##  Các file đã được cập nhật&#10;&#10;### 1. `application.yml` (MỚI)&#10;- Đã cấu hình đầy đủ database + JWT&#10;- Hỗ trợ đọc từ environment variables&#10;- Có giá trị mặc định (fallback)&#10;&#10;### 2. `JwtUtils.java`&#10;- Đã đổi từ `${JWT_SECRET}` → `${jwt.secret}`&#10;- Đã đổi từ `${JWT_EXPIRATION}` → `${jwt.expiration}`&#10;&#10;### 3. File `.env`&#10;- Vẫn giữ nguyên để làm template&#10;&#10;---&#10;&#10;## ❗ Lỗi thường gặp&#10;&#10;### Lỗi: &quot;Could not resolve placeholder 'JWT_SECRET'&quot;&#10;**Nguyên nhân:** Spring không tìm thấy environment variable&#10;&#10;**Giải pháp:**&#10;1. Kiểm tra lại Environment Variables trong Run Configuration&#10;2. Đảm bảo tên biến chính xác (JWT_SECRET, không có dấu cách)&#10;3. Restart IntelliJ IDEA nếu cần&#10;&#10;### Lỗi: &quot;Failed to configure a DataSource&quot;&#10;**Nguyên nhân:** Không có DB_URL, DB_USER, DB_PASS&#10;&#10;**Giải pháp:**&#10;1. Kiểm tra PostgreSQL đang chạy&#10;2. Kiểm tra Environment Variables có đủ cả 3 biến DB&#10;3. Kiểm tra connection string đúng&#10;&#10;---&#10;&#10;##  Bảo mật&#10;&#10;**QUAN TRỌNG:**&#10;- ❌ KHÔNG commit file `.env` lên Git&#10;- ✅ Đã có `.gitignore` để ignore file `.env`&#10;- ✅ Tạo file `.env.example` (không có giá trị thật) để chia sẻ&#10;- ✅ Sử dụng các giá trị khác nhau cho dev/staging/production&#10;&#10;---&#10;&#10;**Bạn có câu hỏi gì không? Hoặc muốn tôi giải thích chi tiết hơn về cách nào?**&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/BE/sale-tech-web/QUICK_START.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/BE/sale-tech-web/QUICK_START.md" />
              <option name="updatedContent" value="#  Quick Start Guide&#10;&#10;## Chạy ứng dụng nhanh nhất&#10;&#10;### Cách 1: IntelliJ IDEA (KHUYẾN NGHỊ)&#10;&#10;1. Mở **Run &gt; Edit Configurations...**&#10;2. Chọn `SaleTechWebApplication`&#10;3. Thêm Environment Variables:&#10;   ```&#10;   DB_URL=jdbc:postgresql://localhost:5432/salestechweb&#10;   DB_USER=postgres&#10;   DB_PASS=Qazedc123S&#10;   JWT_SECRET=Y29tRXhhbXBsZVNlY3JldEtleTIwMjUyMjAzMTY&#10;   JWT_EXPIRATION=86400000&#10;   ```&#10;4. Chạy (Shift+F10)&#10;&#10;### Cách 2: PowerShell Script&#10;&#10;```powershell&#10;.\run-with-env.ps1&#10;```&#10;&#10;### Cách 3: Maven Command&#10;&#10;```powershell&#10;mvn spring-boot:run&#10;```&#10;&#10;---&#10;&#10;##  Chi tiết xem file: `ENVIRONMENT_SETUP.md`&#10;&#10;- Hướng dẫn chi tiết từng cách&#10;- Troubleshooting&#10;- Best practices&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/BE/sale-tech-web/run-with-env.ps1">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/BE/sale-tech-web/run-with-env.ps1" />
              <option name="updatedContent" value="# Script để load .env và chạy Spring Boot application&#10;# Sử dụng: .\run-with-env.ps1&#10;&#10;Write-Host &quot;=== Loading Environment Variables from .env file ===&quot; -ForegroundColor Green&#10;&#10;# Kiểm tra file .env có tồn tại không&#10;if (-Not (Test-Path &quot;.env&quot;)) {&#10;    Write-Host &quot;ERROR: File .env không tồn tại!&quot; -ForegroundColor Red&#10;    Write-Host &quot;Vui lòng tạo file .env từ template .env.example&quot; -ForegroundColor Yellow&#10;    exit 1&#10;}&#10;&#10;# Đọc và load các biến từ .env file&#10;Get-Content .env | ForEach-Object {&#10;    # Bỏ qua dòng comment và dòng trống&#10;    if ($_ -match '^\s*#' -or $_ -match '^\s*$') {&#10;        return&#10;    }&#10;    &#10;    # Parse dòng có format KEY=VALUE&#10;    if ($_ -match '^([^=]+)=(.*)$') {&#10;        $name = $matches[1].Trim()&#10;        $value = $matches[2].Trim()&#10;        &#10;        # Set environment variable cho process hiện tại&#10;        [Environment]::SetEnvironmentVariable($name, $value, 'Process')&#10;        Write-Host &quot;  ✓ Loaded: $name&quot; -ForegroundColor Cyan&#10;    }&#10;}&#10;&#10;Write-Host &quot;`n=== Starting Spring Boot Application ===&quot; -ForegroundColor Green&#10;Write-Host &quot;Press Ctrl+C to stop the application`n&quot; -ForegroundColor Yellow&#10;&#10;# Chạy Maven Spring Boot&#10;mvn spring-boot:run&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/BE/sale-tech-web/src/main/resources/insert_categories.sql">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/BE/sale-tech-web/src/main/resources/insert_categories.sql" />
              <option name="updatedContent" value="-- Insert sample categories if not exists&#10;-- Run this script if your categories table is empty&#10;&#10;-- Check if categories exist&#10;DO $$&#10;BEGIN&#10;    IF NOT EXISTS (SELECT 1 FROM categories LIMIT 1) THEN&#10;        -- Insert default categories&#10;        INSERT INTO categories (name) VALUES &#10;            ('Máy tính xách tay'),&#10;            ('Điện thoại di động'),&#10;            ('Phụ kiện'),&#10;            ('Màn hình'),&#10;            ('Bàn phím'),&#10;            ('Chuột'),&#10;            ('Tai nghe');&#10;        &#10;        RAISE NOTICE 'Categories inserted successfully';&#10;    ELSE&#10;        RAISE NOTICE 'Categories already exist';&#10;    END IF;&#10;END $$;&#10;&#10;-- Verify categories&#10;SELECT * FROM categories ORDER BY id;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Documents/Frontend_JWT_Analysis.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Documents/Frontend_JWT_Analysis.md" />
              <option name="updatedContent" value="#  Phân Tích: JWT Token ở Frontend &amp; Code Redundancy&#10;&#10;##  CÂU HỎI 1: Frontend có thể lấy userId từ JWT token không?&#10;&#10;### **Câu Trả Lời: CÓ - Nhưng KHÔNG NÊN!**&#10;&#10;---&#10;&#10;##  JWT Token Structure&#10;&#10;JWT token có 3 phần:&#10;```&#10;eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJ1c2VyMTIzIiwiaWF0IjoxNzAwMTIzNDU2fQ.signature&#10;│                    │ │                                              │ │         │&#10;│    HEADER          │ │              PAYLOAD (BASE64)                │ │SIGNATURE│&#10;```&#10;&#10;### **Payload chứa:**&#10;```json&#10;{&#10;  &quot;sub&quot;: &quot;username&quot;,      // Subject (username)&#10;  &quot;iat&quot;: 1700123456,      // Issued At (timestamp)&#10;  &quot;exp&quot;: 1700209856       // Expiration (timestamp)&#10;}&#10;```&#10;&#10;---&#10;&#10;## ✅ Frontend CÓ THỂ decode JWT&#10;&#10;```javascript&#10;// Decode JWT token ở frontend (KHÔNG cần secret key)&#10;function parseJwt(token) {&#10;    try {&#10;        const base64Url = token.split('.')[1];  // Lấy phần payload&#10;        const base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');&#10;        const jsonPayload = decodeURIComponent(&#10;            atob(base64)&#10;                .split('')&#10;                .map(c =&gt; '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2))&#10;                .join('')&#10;        );&#10;        return JSON.parse(jsonPayload);&#10;    } catch (error) {&#10;        return null;&#10;    }&#10;}&#10;&#10;// Sử dụng:&#10;const token = localStorage.getItem('token');&#10;const payload = parseJwt(token);&#10;console.log(payload.sub);  // username&#10;console.log(payload.iat);  // issued at&#10;console.log(payload.exp);  // expiration&#10;```&#10;&#10;---&#10;&#10;## ❌ NHƯNG TẠI SAO KHÔNG NÊN?&#10;&#10;### **1. JWT của bạn KHÔNG chứa userId**&#10;&#10;Backend chỉ lưu `username` vào token:&#10;```java&#10;// JwtUtils.java&#10;public String generateToken(String username) {&#10;    return Jwts.builder()&#10;            .subject(username)  // ← Chỉ có username, KHÔNG có userId&#10;            .issuedAt(new Date())&#10;            .expiration(new Date((new Date()).getTime() + jwtExp))&#10;            .signWith(key)&#10;            .compact();&#10;}&#10;```&#10;&#10;**→ Token chỉ có `username`, KHÔNG có `userId`, `email`, `role`, etc.**&#10;&#10;---&#10;&#10;### **2. Backend trả về đầy đủ thông tin khi login**&#10;&#10;```javascript&#10;// Response từ backend khi login:&#10;{&#10;    &quot;token&quot;: &quot;eyJhbGc...&quot;,&#10;    &quot;username&quot;: &quot;john_doe&quot;,&#10;    &quot;name&quot;: &quot;John Doe&quot;, &#10;    &quot;imageUrl&quot;: &quot;http://...&quot;&#10;}&#10;```&#10;&#10;**→ Frontend ĐÃ CÓ SẴN thông tin, không cần decode token!**&#10;&#10;---&#10;&#10;### **3. Security Concerns**&#10;&#10;- ❌ JWT token có thể decode BỞI BẤT KỲ AI (không cần secret key)&#10;- ❌ Không nên lưu sensitive data vào JWT (userId, email, etc.)&#10;- ❌ Nếu cần userId → Backend phải thêm vào payload khi generate token&#10;&#10;---&#10;&#10;##  CÁCH ĐÚNG: Lưu thông tin từ Login Response&#10;&#10;### **Hiện tại (ĐÚNG):**&#10;```javascript&#10;// AuthAPI.js&#10;if (response.data.token) {&#10;    localStorage.setItem('token', response.data.token);&#10;    localStorage.setItem('username', response.data.username);&#10;    localStorage.setItem('name', response.data.name);&#10;    localStorage.setItem('imageUrl', response.data.imageUrl || '');&#10;}&#10;```&#10;&#10;**→ Lấy từ response, KHÔNG cần decode token!**&#10;&#10;---&#10;&#10;##  CÂU HỎI 2: Code bị thừa ở đâu?&#10;&#10;### **VẤN ĐỀ: Duplicate axios instance &amp; interceptors**&#10;&#10;#### **File 1: `apiClient.js`**&#10;```javascript&#10;const apiClient = axios.create({&#10;    baseURL: 'http://localhost:8080',&#10;    headers: { 'Content-Type': 'application/json' },&#10;});&#10;&#10;apiClient.interceptors.request.use(...)   // ← Interceptor 1&#10;apiClient.interceptors.response.use(...)  // ← Response handler 1&#10;```&#10;&#10;#### **File 2: `AuthAPI.js`**&#10;```javascript&#10;const axiosInstance = axios.create({&#10;    baseURL: 'http://localhost:8080/auth',&#10;    headers: { 'Content-Type': 'application/json' },&#10;});&#10;&#10;axiosInstance.interceptors.request.use(...)  // ← Interceptor 2 (DUPLICATE!)&#10;// KHÔNG CÓ response interceptor&#10;```&#10;&#10;---&#10;&#10;## ❌ VẤN ĐỀ:&#10;&#10;1. **Duplicate code**: 2 axios instances với cùng logic&#10;2. **Inconsistent**: `AuthAPI.js` KHÔNG có error handler 401&#10;3. **Maintenance**: Sửa 1 chỗ phải sửa 2 chỗ&#10;&#10;---&#10;&#10;## ✅ GIẢI PHÁP: Dùng chung `apiClient`&#10;&#10;### **Cấu trúc đúng:**&#10;&#10;```&#10;src/api/&#10;  ├── apiClient.js       ← Axios instance chung (shared)&#10;  ├── AuthAPI.js         ← Dùng apiClient, chỉ define methods&#10;  ├── CartAPI.js         ← Dùng apiClient&#10;  ├── ProductAPI.js      ← Dùng apiClient&#10;  └── OrderAPI.js        ← Dùng apiClient&#10;```&#10;&#10;---&#10;&#10;##  CODE SAU KHI SỬA:&#10;&#10;### **apiClient.js** (GIỮ NGUYÊN)&#10;```javascript&#10;import axios from 'axios';&#10;&#10;const BASE_URL = 'http://localhost:8080';&#10;&#10;const apiClient = axios.create({&#10;    baseURL: BASE_URL,&#10;    headers: {&#10;        'Content-Type': 'application/json',&#10;    },&#10;});&#10;&#10;// Request interceptor - thêm token&#10;apiClient.interceptors.request.use(&#10;    (config) =&gt; {&#10;        const token = localStorage.getItem('token');&#10;        if (token) {&#10;            config.headers.Authorization = `Bearer ${token}`;&#10;        }&#10;        return config;&#10;    },&#10;    (error) =&gt; Promise.reject(error)&#10;);&#10;&#10;// Response interceptor - handle 401&#10;apiClient.interceptors.response.use(&#10;    (response) =&gt; response,&#10;    (error) =&gt; {&#10;        if (error.response?.status === 401) {&#10;            localStorage.removeItem('token');&#10;            localStorage.removeItem('username');&#10;            localStorage.removeItem('name');&#10;            localStorage.removeItem('imageUrl');&#10;            window.location.href = '/login';&#10;        }&#10;        return Promise.reject(error);&#10;    }&#10;);&#10;&#10;export default apiClient;&#10;```&#10;&#10;---&#10;&#10;### **AuthAPI.js** (SỬA)&#10;```javascript&#10;import apiClient from './apiClient';  // ← Dùng shared instance&#10;&#10;// Hàm đăng nhập&#10;export const login = async (username, password) =&gt; {&#10;    try {&#10;        const response = await apiClient.post('/auth/login', {&#10;            username,&#10;            password,&#10;        });&#10;&#10;        // Lưu thông tin user và token vào localStorage&#10;        if (response.data.token) {&#10;            localStorage.setItem('token', response.data.token);&#10;            localStorage.setItem('username', response.data.username);&#10;            localStorage.setItem('name', response.data.name);&#10;            localStorage.setItem('imageUrl', response.data.imageUrl || '');&#10;        }&#10;&#10;        return {&#10;            success: true,&#10;            data: response.data,&#10;        };&#10;    } catch (error) {&#10;        return {&#10;            success: false,&#10;            message: error.response?.data || 'Login failed. Please check your credentials.',&#10;        };&#10;    }&#10;};&#10;&#10;// Hàm đăng ký&#10;export const register = async (userData) =&gt; {&#10;    try {&#10;        const response = await apiClient.post('/auth/register', {&#10;            username: userData.username,&#10;            password: userData.password,&#10;            confirmPassword: userData.confirmPassword,&#10;            email: userData.email,&#10;            phone: userData.phone,&#10;            name: userData.name,&#10;        });&#10;&#10;        return {&#10;            success: true,&#10;            message: response.data,&#10;        };&#10;    } catch (error) {&#10;        return {&#10;            success: false,&#10;            message: error.response?.data || 'Registration failed. Please try again.',&#10;        };&#10;    }&#10;};&#10;&#10;// Hàm đăng xuất&#10;export const logout = () =&gt; {&#10;    localStorage.removeItem('token');&#10;    localStorage.removeItem('username');&#10;    localStorage.removeItem('name');&#10;    localStorage.removeItem('imageUrl');&#10;};&#10;&#10;// Kiểm tra xem user đã đăng nhập chưa&#10;export const isAuthenticated = () =&gt; {&#10;    return !!localStorage.getItem('token');&#10;};&#10;&#10;// Lấy thông tin user hiện tại&#10;export const getCurrentUser = () =&gt; {&#10;    return {&#10;        token: localStorage.getItem('token'),&#10;        username: localStorage.getItem('username'),&#10;        name: localStorage.getItem('name'),&#10;        imageUrl: localStorage.getItem('imageUrl'),&#10;    };&#10;};&#10;```&#10;&#10;---&#10;&#10;##  SO SÁNH: TRƯỚC &amp; SAU&#10;&#10;### **❌ TRƯỚC:**&#10;- 2 axios instances&#10;- 2 request interceptors (duplicate)&#10;- 1 response interceptor (thiếu ở AuthAPI)&#10;- Khó maintain&#10;&#10;### **✅ SAU:**&#10;- 1 axios instance (shared)&#10;- 1 request interceptor (centralized)&#10;- 1 response interceptor (handle 401 toàn app)&#10;- Dễ maintain, consistent&#10;&#10;---&#10;&#10;##  LỢI ÍCH:&#10;&#10;1. **DRY Principle**: Don't Repeat Yourself&#10;2. **Centralized**: Tất cả config ở 1 chỗ&#10;3. **Consistent**: Cùng behavior cho toàn bộ API calls&#10;4. **Easy to maintain**: Sửa 1 chỗ, apply cho tất cả&#10;&#10;---&#10;&#10;##  KẾT LUẬN:&#10;&#10;### **Câu hỏi 1: Frontend có lấy được userId từ token không?**&#10;- ✅ CÓ thể decode JWT (không cần secret key)&#10;- ❌ NHƯNG token của bạn KHÔNG chứa userId&#10;- ✅ Frontend ĐÃ CÓ thông tin từ login response&#10;- **→ KHÔNG CẦN decode token!**&#10;&#10;### **Câu hỏi 2: Code bị thừa?**&#10;- ❌ `AuthAPI.js` tạo axios instance riêng (duplicate)&#10;- ❌ Duplicate request interceptor&#10;- ✅ Nên dùng chung `apiClient` cho tất cả API calls&#10;&#10;---&#10;&#10;**Tác giả:** GitHub Copilot  &#10;**Version:** 1.0  &#10;**Date:** 2025-11-21&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Documents/Frontend_JWT_Summary.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Documents/Frontend_JWT_Summary.md" />
              <option name="updatedContent" value="# ✅ Tóm Tắt: JWT Token ở Frontend&#10;&#10;##  Câu hỏi của bạn:&#10;&#10;### **1. Frontend có thể lấy userId từ JWT token không?**&#10;&#10;**Trả lời ngắn gọn:**&#10;&#10;- ✅ **CÓ** - Frontend có thể decode JWT token (không cần secret key)&#10;- ❌ **NHƯNG** - Token của bạn KHÔNG chứa userId, chỉ có `username`&#10;- ✅ **GIẢI PHÁP** - Backend đã trả về đầy đủ thông tin trong login response:&#10;&#10;```javascript&#10;// Response khi login:&#10;{&#10;    &quot;token&quot;: &quot;eyJhbGc...&quot;,&#10;    &quot;username&quot;: &quot;john_doe&quot;,&#10;    &quot;name&quot;: &quot;John Doe&quot;,&#10;    &quot;imageUrl&quot;: &quot;...&quot;&#10;}&#10;```&#10;&#10;**→ Lưu thông tin từ response, KHÔNG cần decode token!**&#10;&#10;---&#10;&#10;### **2. Code bị thừa ở đâu?**&#10;&#10;**Vấn đề:**&#10;- ❌ `AuthAPI.js` tạo axios instance riêng&#10;- ❌ Duplicate interceptor (thêm token vào header)&#10;- ❌ Không consistent với các API khác&#10;&#10;**Đã sửa:**&#10;- ✅ Dùng chung `apiClient` từ `apiClient.js`&#10;- ✅ Xóa axios instance riêng&#10;- ✅ Xóa duplicate interceptor&#10;- ✅ Fix error handling với optional chaining (`?.`)&#10;&#10;---&#10;&#10;##  Thay đổi:&#10;&#10;### **TRƯỚC:**&#10;```javascript&#10;import axios from 'axios';&#10;&#10;const axiosInstance = axios.create({...});&#10;axiosInstance.interceptors.request.use(...);  // Duplicate!&#10;&#10;export const login = async () =&gt; {&#10;    await axiosInstance.post('/login', ...);&#10;};&#10;```&#10;&#10;### **SAU:**&#10;```javascript&#10;import apiClient from './apiClient';  // Dùng chung&#10;&#10;export const login = async () =&gt; {&#10;    await apiClient.post('/auth/login', ...);  // Clean!&#10;};&#10;```&#10;&#10;---&#10;&#10;##  Lợi ích:&#10;&#10;1. ✅ **Không duplicate code**&#10;2. ✅ **Centralized configuration** - Tất cả config ở `apiClient.js`&#10;3. ✅ **Consistent** - Tất cả API calls dùng cùng logic&#10;4. ✅ **Auto handle 401** - Tự động redirect về login khi token hết hạn&#10;&#10;---&#10;&#10;**Kết luận:** Code đã clean và không còn thừa! &#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Documents/JWT_Security_Architecture.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Documents/JWT_Security_Architecture.md" />
              <option name="updatedContent" value="#  Kiến Trúc JWT Security - Spring Boot Application&#10;&#10;**Tài liệu:** Giải thích chi tiết về JWT Authentication &amp; Authorization  &#10;**Ngày tạo:** 2025-11-21  &#10;**Version:** 1.0&#10;&#10;---&#10;&#10;##  MỤC LỤC&#10;&#10;1. [Tổng Quan Kiến Trúc](#1-tổng-quan-kiến-trúc)&#10;2. [JwtUtils - JWT Token Manager](#2-jwtutils---jwt-token-manager)&#10;3. [AuthTokenFilter - Request Filter](#3-authtokenfilter---request-filter)&#10;4. [WebSecurityConfig - Security Configuration](#4-websecurityconfig---security-configuration)&#10;5. [SecurityUtils - Helper Utility](#5-securityutils---helper-utility)&#10;6. [Luồng Hoạt Động (Flow)](#6-luồng-hoạt-động-flow)&#10;7. [Use Cases Thực Tế](#7-use-cases-thực-tế)&#10;&#10;---&#10;&#10;## 1. TỔNG QUAN KIẾN TRÚC&#10;&#10;### **Mô Hình Tổng Thể:**&#10;&#10;```&#10;┌─────────────┐&#10;│   CLIENT    │&#10;│  (Browser)  │&#10;└──────┬──────┘&#10;       │ 1. HTTP Request + JWT Token&#10;       │    Header: Authorization: Bearer &lt;token&gt;&#10;       ↓&#10;┌─────────────────────────────────────────┐&#10;│      SPRING BOOT APPLICATION            │&#10;│                                         │&#10;│  ┌───────────────────────────────────┐ │&#10;│  │   WebSecurityConfig               │ │&#10;│  │   - Cấu hình Security             │ │&#10;│  │   - CORS Configuration            │ │&#10;│  └───────────┬───────────────────────┘ │&#10;│              │                          │&#10;│              ↓                          │&#10;│  ┌───────────────────────────────────┐ │&#10;│  │   AuthTokenFilter                 │ │ ← Filter mỗi request&#10;│  │   - Parse JWT Token               │ │&#10;│  │   - Validate Token                │ │&#10;│  │   - Set Authentication            │ │&#10;│  └───────────┬───────────────────────┘ │&#10;│              │ (uses)                   │&#10;│              ↓                          │&#10;│  ┌───────────────────────────────────┐ │&#10;│  │   JwtUtils                        │ │ ← JWT Operations&#10;│  │   - Generate Token                │ │&#10;│  │   - Parse Token                   │ │&#10;│  │   - Validate Token                │ │&#10;│  └───────────────────────────────────┘ │&#10;│                                         │&#10;│              ↓                          │&#10;│  ┌───────────────────────────────────┐ │&#10;│  │   SecurityContextHolder           │ │ ← Spring Security Core&#10;│  │   - Store Authentication          │ │&#10;│  └───────────┬───────────────────────┘ │&#10;│              │                          │&#10;│              ↓                          │&#10;│  ┌───────────────────────────────────┐ │&#10;│  │   SecurityUtils                   │ │ ← Helper để lấy user&#10;│  │   - Get Current User              │ │&#10;│  └───────────┬───────────────────────┘ │&#10;│              │                          │&#10;│              ↓                          │&#10;│  ┌───────────────────────────────────┐ │&#10;│  │   Controller → Service            │ │&#10;│  │   - Business Logic                │ │&#10;│  └───────────────────────────────────┘ │&#10;│                                         │&#10;└─────────────────────────────────────────┘&#10;```&#10;&#10;---&#10;&#10;## 2. JWTUTILS - JWT TOKEN MANAGER&#10;&#10;### ** Location:**&#10;```&#10;src/main/java/com/example/sale_tech_web/feature/jwt/JwtUtils.java&#10;```&#10;&#10;### ** Chức Năng:**&#10;Quản lý toàn bộ operations liên quan đến JWT Token:&#10;- Generate (Tạo token)&#10;- Parse (Đọc thông tin từ token)&#10;- Validate (Kiểm tra tính hợp lệ)&#10;&#10;---&#10;&#10;### ** CHI TIẾT CODE:**&#10;&#10;#### **1. Configuration Properties**&#10;&#10;```java&#10;@Value(&quot;${JWT_SECRET}&quot;)&#10;private String jwtSecret;  // Secret key để sign token&#10;&#10;@Value(&quot;${JWT_EXPIRATION}&quot;)&#10;private int jwtExp;        // Thời gian hết hạn (milliseconds)&#10;```&#10;&#10;**Giải thích:**&#10;- `JWT_SECRET`: Khóa bí mật để mã hóa token (phải giữ bí mật!)&#10;- `JWT_EXPIRATION`: Thời gian token có hiệu lực (ví dụ: 86400000 = 24 giờ)&#10;- Đọc từ environment variables hoặc `application.properties`&#10;&#10;**Ví dụ config:**&#10;```properties&#10;# application.properties&#10;JWT_SECRET=MyVerySecretKeyThatIsAtLeast256BitsLongForHS256Algorithm&#10;JWT_EXPIRATION=86400000&#10;```&#10;&#10;---&#10;&#10;#### **2. Generate Token - Tạo JWT Token**&#10;&#10;```java&#10;public String generateToken(String username) {&#10;    // 1. Tạo secret key từ jwtSecret&#10;    SecretKey key = Keys.hmacShaKeyFor(jwtSecret.getBytes(StandardCharsets.UTF_8));&#10;    &#10;    // 2. Build JWT token&#10;    return Jwts.builder()&#10;            .subject(username)                                    // Payload: username&#10;            .issuedAt(new Date())                                // Thời gian tạo&#10;            .expiration(new Date((new Date()).getTime() + jwtExp)) // Thời gian hết hạn&#10;            .signWith(key)                                       // Ký token với secret key&#10;            .compact();                                          // Tạo string token&#10;}&#10;```&#10;&#10;**Cấu Trúc JWT Token:**&#10;```&#10;eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJ1c2VyMTIzIiwiaWF0IjoxNjk5MTI...&#10;│                    │ │                                        │&#10;│    HEADER          │ │         PAYLOAD                        │  SIGNATURE&#10;│  (Algorithm: HS256)│ │  (subject: username, iat, exp)         │  (Chữ ký)&#10;```&#10;&#10;**Khi nào gọi:**&#10;- Khi user đăng nhập thành công&#10;- Khi user đăng ký thành công (auto login)&#10;&#10;**Ví dụ sử dụng:**&#10;```java&#10;// Trong AuthController/UserService&#10;public LogInResponse login(LogInRequest request) {&#10;    // ... validate username &amp; password ...&#10;    &#10;    String token = jwtUtils.generateToken(username);  // ← Generate token&#10;    &#10;    return LogInResponse.builder()&#10;        .token(token)&#10;        .username(username)&#10;        .build();&#10;}&#10;```&#10;&#10;---&#10;&#10;#### **3. Get Username From Token - Đọc Username**&#10;&#10;```java&#10;public String getUsernameFromJwtToken(String token) {&#10;    // 1. Tạo secret key&#10;    SecretKey key = Keys.hmacShaKeyFor(jwtSecret.getBytes(StandardCharsets.UTF_8));&#10;    &#10;    // 2. Parse token và lấy username từ subject&#10;    return Jwts.parser()&#10;            .verifyWith(key)           // Verify signature với key&#10;            .build()&#10;            .parseSignedClaims(token)  // Parse token&#10;            .getPayload()              // Lấy payload (claims)&#10;            .getSubject();             // Lấy subject = username&#10;}&#10;```&#10;&#10;**Giải thích:**&#10;- Parse JWT token để lấy thông tin username&#10;- Verify signature để đảm bảo token không bị giả mạo&#10;- Trả về `subject` (đã set khi generate = username)&#10;&#10;**Khi nào gọi:**&#10;- Trong `AuthTokenFilter` để lấy username từ token&#10;- Để identify user đang request&#10;&#10;---&#10;&#10;#### **4. Validate Token - Kiểm Tra Token Hợp Lệ**&#10;&#10;```java&#10;public boolean validateToken(String token) {&#10;    try {&#10;        SecretKey key = Keys.hmacShaKeyFor(jwtSecret.getBytes(StandardCharsets.UTF_8));&#10;        Jwts.parser().verifyWith(key).build().parseSignedClaims(token);&#10;        return true;  // Token hợp lệ&#10;        &#10;    } catch (MalformedJwtException e) {&#10;        log.error(&quot;Invalid JWT token: {}&quot;, e.getMessage());&#10;        // Token sai format&#10;        &#10;    } catch (ExpiredJwtException e) {&#10;        log.error(&quot;JWT token is expired: {}&quot;, e.getMessage());&#10;        // Token hết hạn&#10;        &#10;    } catch (UnsupportedJwtException e) {&#10;        log.error(&quot;JWT token is unsupported: {}&quot;, e.getMessage());&#10;        // Algorithm không support&#10;        &#10;    } catch (IllegalArgumentException e) {&#10;        log.error(&quot;JWT claims string is empty: {}&quot;, e.getMessage());&#10;        // Token rỗng&#10;    }&#10;    &#10;    return false;  // Token không hợp lệ&#10;}&#10;```&#10;&#10;**Các Trường Hợp Validate:**&#10;&#10;| Exception | Lý do | Ví dụ |&#10;|-----------|-------|-------|&#10;| `MalformedJwtException` | Token sai format | `&quot;abc123&quot;` thay vì JWT đúng |&#10;| `ExpiredJwtException` | Token đã hết hạn | Token tạo 25 giờ trước (exp = 24h) |&#10;| `UnsupportedJwtException` | Algorithm không hỗ trợ | Token dùng RS256 nhưng server dùng HS256 |&#10;| `IllegalArgumentException` | Token null/empty | `&quot;&quot;` hoặc `null` |&#10;&#10;**Khi nào gọi:**&#10;- Trong `AuthTokenFilter` trước khi set authentication&#10;- Để đảm bảo token hợp lệ trước khi tin tưởng user&#10;&#10;---&#10;&#10;### ** TÓM TẮT JWTUTILS:**&#10;&#10;| Method | Input | Output | Mục đích |&#10;|--------|-------|--------|----------|&#10;| `generateToken()` | username (String) | JWT token (String) | Tạo token khi login |&#10;| `getUsernameFromJwtToken()` | token (String) | username (String) | Lấy username từ token |&#10;| `validateToken()` | token (String) | true/false (boolean) | Kiểm tra token hợp lệ |&#10;&#10;---&#10;&#10;## 3. AUTHTOKENFILTER - REQUEST FILTER&#10;&#10;### ** Location:**&#10;```&#10;src/main/java/com/example/sale_tech_web/config/AuthTokenFilter.java&#10;```&#10;&#10;### ** Chức Năng:**&#10;Filter TỪNG request HTTP để:&#10;1. Extract JWT token từ header&#10;2. Validate token&#10;3. Set authentication vào SecurityContext&#10;4. Cho phép request tiếp tục hoặc reject&#10;&#10;---&#10;&#10;### ** CHI TIẾT CODE:**&#10;&#10;#### **1. Class Declaration**&#10;&#10;```java&#10;@Configuration&#10;@Slf4j&#10;@RequiredArgsConstructor&#10;public class AuthTokenFilter extends OncePerRequestFilter {&#10;    private final JwtUtils jwtUtils;&#10;    &#10;    // ...&#10;}&#10;```&#10;&#10;**Giải thích:**&#10;- `@Configuration`: Spring Bean để được inject vào Security chain&#10;- `extends OncePerRequestFilter`: Đảm bảo filter chỉ chạy 1 lần per request&#10;- `@RequiredArgsConstructor`: Lombok auto-inject `JwtUtils`&#10;&#10;---&#10;&#10;#### **2. Main Filter Logic**&#10;&#10;```java&#10;@Override&#10;protected void doFilterInternal(&#10;    @NonNull HttpServletRequest request,&#10;    @NonNull HttpServletResponse response,&#10;    @NonNull FilterChain filterChain&#10;) throws ServletException, IOException {&#10;    &#10;    // BƯỚC 1: Lấy Authorization header&#10;    final String authHeader = request.getHeader(&quot;Authorization&quot;);&#10;    &#10;    // BƯỚC 2: Check header có tồn tại và đúng format không&#10;    if (authHeader == null || !authHeader.startsWith(&quot;Bearer &quot;)) {&#10;        filterChain.doFilter(request, response);  // Cho qua, không authenticate&#10;        return;&#10;    }&#10;    &#10;    // BƯỚC 3: Extract token (bỏ &quot;Bearer &quot; prefix)&#10;    final String token = authHeader.substring(7);  // &quot;Bearer &quot; = 7 ký tự&#10;    &#10;    // BƯỚC 4: Lấy username từ token&#10;    final String userName = jwtUtils.getUsernameFromJwtToken(token);&#10;    &#10;    // BƯỚC 5: Validate token và set authentication&#10;    if (userName != null &amp;&amp; jwtUtils.validateToken(token)) {&#10;        // Tạo Authentication object&#10;        UsernamePasswordAuthenticationToken authentication =&#10;            new UsernamePasswordAuthenticationToken(&#10;                userName,        // Principal (username)&#10;                null,           // Credentials (không cần password)&#10;                new ArrayList&lt;&gt;() // Authorities (roles - đang để empty)&#10;            );&#10;        &#10;        // Set vào SecurityContext&#10;        SecurityContextHolder.getContext().setAuthentication(authentication);&#10;    }&#10;    &#10;    // BƯỚC 6: Cho request tiếp tục&#10;    filterChain.doFilter(request, response);&#10;}&#10;```&#10;&#10;---&#10;&#10;### ** LUỒNG XỬ LÝ CHI TIẾT:**&#10;&#10;```&#10;┌─────────────────────────────────────────────────┐&#10;│  HTTP Request đến                               │&#10;│  GET /cart                                      │&#10;│  Headers:                                       │&#10;│    Authorization: Bearer eyJhbGc...             │&#10;└────────────────┬────────────────────────────────┘&#10;                 │&#10;                 ↓&#10;┌────────────────────────────────────────────────┐&#10;│ BƯỚC 1: Lấy Authorization Header               │&#10;│ authHeader = &quot;Bearer eyJhbGc...&quot;               │&#10;└────────────────┬───────────────────────────────┘&#10;                 │&#10;                 ↓&#10;┌────────────────────────────────────────────────┐&#10;│ BƯỚC 2: Check Header                           │&#10;│ - authHeader == null? → Cho qua (no auth)      │&#10;│ - !startsWith(&quot;Bearer &quot;)? → Cho qua (no auth)  │&#10;│ - Đúng format? → Tiếp tục                      │&#10;└────────────────┬───────────────────────────────┘&#10;                 │&#10;                 ↓&#10;┌────────────────────────────────────────────────┐&#10;│ BƯỚC 3: Extract Token                          │&#10;│ token = authHeader.substring(7)                │&#10;│ = &quot;eyJhbGc...&quot;                                 │&#10;└────────────────┬───────────────────────────────┘&#10;                 │&#10;                 ↓&#10;┌────────────────────────────────────────────────┐&#10;│ BƯỚC 4: Parse Token → Get Username             │&#10;│ userName = jwtUtils.getUsernameFromJwtToken()  │&#10;│ = &quot;john_doe&quot;                                   │&#10;└────────────────┬───────────────────────────────┘&#10;                 │&#10;                 ↓&#10;┌────────────────────────────────────────────────┐&#10;│ BƯỚC 5: Validate Token                         │&#10;│ if (userName != null &amp;&amp; validateToken(token))  │&#10;│   ✅ Token hợp lệ → Tạo Authentication         │&#10;│   ❌ Token không hợp lệ → Skip authentication  │&#10;└────────────────┬───────────────────────────────┘&#10;                 │&#10;                 ↓&#10;┌────────────────────────────────────────────────┐&#10;│ BƯỚC 6: Set Authentication vào Context         │&#10;│ SecurityContextHolder.getContext()             │&#10;│   .setAuthentication(authentication)           │&#10;│                                                │&#10;│ Authentication object:                         │&#10;│ - Principal: &quot;john_doe&quot;                        │&#10;│ - Credentials: null                            │&#10;│ - Authorities: []                              │&#10;└────────────────┬───────────────────────────────┘&#10;                 │&#10;                 ↓&#10;┌────────────────────────────────────────────────┐&#10;│ BƯỚC 7: Continue Filter Chain                  │&#10;│ filterChain.doFilter(request, response)        │&#10;│ → Request đến Controller                       │&#10;└────────────────────────────────────────────────┘&#10;```&#10;&#10;---&#10;&#10;### ** CASE STUDIES:**&#10;&#10;#### **Case 1: Request Có Token Hợp Lệ**&#10;```http&#10;GET /cart HTTP/1.1&#10;Host: localhost:8080&#10;Authorization: Bearer eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJ1c2VyMTIzIiwiaWF0IjoxNzAwMTIzNDU2...&#10;```&#10;&#10;**Kết quả:**&#10;- ✅ Token được parse&#10;- ✅ Username = &quot;user123&quot;&#10;- ✅ Token valid&#10;- ✅ Authentication được set&#10;- ✅ Request đến Controller với user authenticated&#10;&#10;---&#10;&#10;#### **Case 2: Request Không Có Token**&#10;```http&#10;GET /product HTTP/1.1&#10;Host: localhost:8080&#10;```&#10;&#10;**Kết quả:**&#10;- ⚠️ authHeader = null&#10;- ⚠️ Skip authentication&#10;- ✅ Request vẫn đến Controller (nếu endpoint public)&#10;- ❌ Request bị reject nếu endpoint cần authentication&#10;&#10;---&#10;&#10;#### **Case 3: Request Có Token Hết Hạn**&#10;```http&#10;GET /cart HTTP/1.1&#10;Authorization: Bearer &lt;token_het_han&gt;&#10;```&#10;&#10;**Kết quả:**&#10;- ⚠️ Token được parse&#10;- ❌ validateToken() = false (ExpiredJwtException)&#10;- ❌ Authentication KHÔNG được set&#10;- ❌ Request bị reject (401 Unauthorized)&#10;&#10;---&#10;&#10;### ** TÓM TẮT AUTHTOKENFILTER:**&#10;&#10;| Trường hợp | Header | Token Valid? | Authentication Set? | Kết quả |&#10;|------------|--------|--------------|---------------------|---------|&#10;| Public endpoint + No token | No Authorization | N/A | ❌ No | ✅ Cho qua |&#10;| Public endpoint + Valid token | Bearer xxx | ✅ Yes | ✅ Yes | ✅ Cho qua (with auth) |&#10;| Protected endpoint + No token | No Authorization | N/A | ❌ No | ❌ Reject 401 |&#10;| Protected endpoint + Valid token | Bearer xxx | ✅ Yes | ✅ Yes | ✅ Cho qua |&#10;| Protected endpoint + Invalid token | Bearer xxx | ❌ No | ❌ No | ❌ Reject 401 |&#10;&#10;---&#10;&#10;## 4. WEBSECURITYCONFIG - SECURITY CONFIGURATION&#10;&#10;### ** Location:**&#10;```&#10;src/main/java/com/example/sale_tech_web/config/WebSecurityConfig.java&#10;```&#10;&#10;### ** Chức Năng:**&#10;Cấu hình toàn bộ Security cho ứng dụng:&#10;- Định nghĩa endpoints nào public, nào protected&#10;- Cấu hình CORS&#10;- Thêm AuthTokenFilter vào filter chain&#10;- Cấu hình password encoder&#10;&#10;---&#10;&#10;### ** CHI TIẾT CODE:**&#10;&#10;#### **1. Class Declaration**&#10;&#10;```java&#10;@Configuration&#10;@EnableWebSecurity&#10;@RequiredArgsConstructor&#10;public class WebSecurityConfig {&#10;    private final AuthTokenFilter authTokenFilter;  // Inject filter&#10;    &#10;    // ...&#10;}&#10;```&#10;&#10;**Giải thích:**&#10;- `@Configuration`: Spring Configuration class&#10;- `@EnableWebSecurity`: Enable Spring Security&#10;- Inject `AuthTokenFilter` để thêm vào filter chain&#10;&#10;---&#10;&#10;#### **2. Security Filter Chain - Core Configuration**&#10;&#10;```java&#10;@Bean&#10;public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {&#10;    return http&#10;        // ─────────────────────────────────────────────&#10;        // 1. CSRF Protection&#10;        // ─────────────────────────────────────────────&#10;        .csrf(AbstractHttpConfigurer::disable)&#10;        // Disable CSRF vì dùng JWT (stateless)&#10;        // JWT token không vulnerable với CSRF attacks&#10;        &#10;        // ─────────────────────────────────────────────&#10;        // 2. CORS Configuration&#10;        // ─────────────────────────────────────────────&#10;        .cors(cors -&gt; {})&#10;        // Enable CORS với config từ corsConfigurationSource()&#10;        &#10;        // ─────────────────────────────────────────────&#10;        // 3. Authorization Rules&#10;        // ─────────────────────────────────────────────&#10;        .authorizeHttpRequests(auth -&gt; auth&#10;            // OPTIONS requests → Luôn cho qua (CORS preflight)&#10;            .requestMatchers(HttpMethod.OPTIONS, &quot;/**&quot;).permitAll()&#10;            &#10;            // Public endpoints (không cần authentication)&#10;            .requestMatchers(&quot;/auth/**&quot;, &quot;/product&quot;, &quot;/product/**&quot;).permitAll()&#10;            &#10;            // Tất cả endpoints khác → Cần authentication&#10;            .anyRequest().authenticated()&#10;        )&#10;        &#10;        // ─────────────────────────────────────────────&#10;        // 4. Session Management&#10;        // ─────────────────────────────────────────────&#10;        .sessionManagement(sess -&gt; &#10;            sess.sessionCreationPolicy(SessionCreationPolicy.STATELESS)&#10;        )&#10;        // STATELESS: Không dùng session, mọi request phải có JWT&#10;        &#10;        // ─────────────────────────────────────────────&#10;        // 5. Add Custom Filter&#10;        // ─────────────────────────────────────────────&#10;        .addFilterBefore(&#10;            authTokenFilter,                           // Custom filter&#10;            UsernamePasswordAuthenticationFilter.class // Chạy trước filter này&#10;        )&#10;        &#10;        .build();&#10;}&#10;```&#10;&#10;---&#10;&#10;### ** AUTHORIZATION RULES CHI TIẾT:**&#10;&#10;```&#10;┌────────────────────────────────────────────────────────────┐&#10;│                   HTTP REQUEST FLOW                        │&#10;└────────────────────────────────────────────────────────────┘&#10;&#10;Request: OPTIONS /cart&#10;    ↓&#10;    Check: OPTIONS /**?&#10;    ✅ YES → permitAll() → Cho qua (không cần auth)&#10;&#10;────────────────────────────────────────────────────────────&#10;&#10;Request: POST /auth/login&#10;    ↓&#10;    Check: OPTIONS /**?&#10;    ❌ NO&#10;    ↓&#10;    Check: /auth/**?&#10;    ✅ YES → permitAll() → Cho qua (không cần auth)&#10;&#10;────────────────────────────────────────────────────────────&#10;&#10;Request: GET /product/123&#10;    ↓&#10;    Check: OPTIONS /**?&#10;    ❌ NO&#10;    ↓&#10;    Check: /auth/**?&#10;    ❌ NO&#10;    ↓&#10;    Check: /product/**?&#10;    ✅ YES → permitAll() → Cho qua (không cần auth)&#10;&#10;────────────────────────────────────────────────────────────&#10;&#10;Request: GET /cart&#10;    ↓&#10;    Check: OPTIONS /**?&#10;    ❌ NO&#10;    ↓&#10;    Check: /auth/**?&#10;    ❌ NO&#10;    ↓&#10;    Check: /product/**?&#10;    ❌ NO&#10;    ↓&#10;    anyRequest().authenticated()&#10;    ⚠️ NEED AUTHENTICATION&#10;    ↓&#10;    Check: SecurityContext có Authentication?&#10;    ✅ YES → Cho qua&#10;    ❌ NO → Reject 401 Unauthorized&#10;```&#10;&#10;---&#10;&#10;#### **3. CORS Configuration**&#10;&#10;```java&#10;@Bean&#10;public CorsConfigurationSource corsConfigurationSource() {&#10;    CorsConfiguration config = new CorsConfiguration();&#10;    &#10;    // ─────────────────────────────────────────────&#10;    // Allowed Origins (Frontend URLs)&#10;    // ─────────────────────────────────────────────&#10;    config.setAllowedOrigins(List.of(&quot;http://localhost:3000&quot;));&#10;    // Chỉ cho phép requests từ localhost:3000 (React app)&#10;    &#10;    // ─────────────────────────────────────────────&#10;    // Allowed HTTP Methods&#10;    // ─────────────────────────────────────────────&#10;    config.setAllowedMethods(&#10;        List.of(&quot;GET&quot;, &quot;POST&quot;, &quot;PUT&quot;, &quot;PATCH&quot;, &quot;DELETE&quot;, &quot;OPTIONS&quot;)&#10;    );&#10;    &#10;    // ─────────────────────────────────────────────&#10;    // Allowed Headers (Frontend có thể gửi)&#10;    // ─────────────────────────────────────────────&#10;    config.setAllowedHeaders(&#10;        List.of(&quot;Authorization&quot;, &quot;Content-Type&quot;, &quot;Accept&quot;, &#10;                &quot;Origin&quot;, &quot;X-Requested-With&quot;)&#10;    );&#10;    // Frontend có thể gửi các headers này&#10;    &#10;    // ─────────────────────────────────────────────&#10;    // Exposed Headers (Frontend có thể đọc)&#10;    // ─────────────────────────────────────────────&#10;    config.setExposedHeaders(&#10;        List.of(&quot;Authorization&quot;, &quot;Location&quot;)&#10;    );&#10;    // Frontend có thể đọc Authorization header từ response&#10;    &#10;    // ─────────────────────────────────────────────&#10;    // Credentials (Cookies, Authorization headers)&#10;    // ─────────────────────────────────────────────&#10;    config.setAllowCredentials(true);&#10;    // Cho phép gửi credentials (JWT token trong header)&#10;    &#10;    // ─────────────────────────────────────────────&#10;    // Preflight Cache (OPTIONS request)&#10;    // ─────────────────────────────────────────────&#10;    config.setMaxAge(3600L);&#10;    // Cache preflight request trong 1 giờ&#10;    &#10;    // ─────────────────────────────────────────────&#10;    // Apply Configuration&#10;    // ─────────────────────────────────────────────&#10;    UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();&#10;    source.registerCorsConfiguration(&quot;/**&quot;, config);&#10;    return source;&#10;}&#10;```&#10;&#10;**Giải thích CORS:**&#10;&#10;CORS (Cross-Origin Resource Sharing) cho phép Frontend (localhost:3000) gọi API Backend (localhost:8080).&#10;&#10;**Ví dụ:**&#10;```javascript&#10;// Frontend (React) gọi API&#10;fetch('http://localhost:8080/cart', {&#10;    method: 'GET',&#10;    headers: {&#10;        'Authorization': 'Bearer eyJhbGc...',  // ✅ Allowed&#10;        'Content-Type': 'application/json'     // ✅ Allowed&#10;    },&#10;    credentials: 'include'  // ✅ allowCredentials = true&#10;})&#10;```&#10;&#10;---&#10;&#10;#### **4. Password Encoder**&#10;&#10;```java&#10;@Bean&#10;public PasswordEncoder passwordEncoder() {&#10;    return new BCryptPasswordEncoder();&#10;}&#10;```&#10;&#10;**Giải thích:**&#10;- Dùng BCrypt algorithm để hash password&#10;- Khi user đăng ký: `passwordEncoder.encode(&quot;password123&quot;)` → Hash&#10;- Khi user login: `passwordEncoder.matches(&quot;password123&quot;, hashedPassword)` → Verify&#10;&#10;**Ví dụ:**&#10;```java&#10;// Register&#10;String hashedPassword = passwordEncoder.encode(&quot;MyPassword123!&quot;);&#10;// → &quot;$2a$10$N9qo8uLOickgx2ZMRZoMye...&quot;&#10;&#10;// Login&#10;boolean matches = passwordEncoder.matches(&quot;MyPassword123!&quot;, hashedPassword);&#10;// → true&#10;```&#10;&#10;---&#10;&#10;### ** TÓM TẮT WEBSECURITYCONFIG:**&#10;&#10;| Component | Mục đích | Giá trị |&#10;|-----------|----------|---------|&#10;| **CSRF** | Protection | Disabled (dùng JWT) |&#10;| **CORS** | Cross-Origin | localhost:3000 allowed |&#10;| **Session** | Stateful/Stateless | STATELESS (JWT) |&#10;| **Public Endpoints** | Không cần auth | `/auth/**`, `/product/**` |&#10;| **Protected Endpoints** | Cần auth | `/cart`, `/order`, etc. |&#10;| **Password Encoder** | Hash algorithm | BCrypt |&#10;| **Custom Filter** | JWT validation | AuthTokenFilter |&#10;&#10;---&#10;&#10;## 5. SECURITYUTILS - HELPER UTILITY&#10;&#10;### ** Location:**&#10;```&#10;src/main/java/com/example/sale_tech_web/utils/SecurityUtils.java&#10;```&#10;&#10;### ** Chức Năng:**&#10;Helper class để lấy thông tin user hiện tại từ SecurityContext&#10;&#10;---&#10;&#10;### ** CHI TIẾT CODE:**&#10;&#10;#### **1. Get Current Username**&#10;&#10;```java&#10;public static String getCurrentUsername() {&#10;    // 1. Lấy Authentication từ SecurityContext&#10;    Authentication authentication = SecurityContextHolder&#10;        .getContext()&#10;        .getAuthentication();&#10;    &#10;    // 2. Check authentication tồn tại và hợp lệ&#10;    if (authentication != null &#10;        &amp;&amp; authentication.isAuthenticated()&#10;        &amp;&amp; !authentication.getName().equals(&quot;anonymousUser&quot;)) {&#10;        &#10;        return authentication.getName();  // Trả về username&#10;    }&#10;    &#10;    return null;  // Chưa login&#10;}&#10;```&#10;&#10;**Giải thích:**&#10;&#10;1. **SecurityContextHolder**: Thread-local storage cho Authentication&#10;2. **getAuthentication()**: Lấy Authentication object (đã set bởi AuthTokenFilter)&#10;3. **isAuthenticated()**: Check user đã authenticated chưa&#10;4. **!equals(&quot;anonymousUser&quot;)**: Spring Security default anonymous user&#10;5. **getName()**: Lấy principal = username&#10;&#10;**Khi nào dùng:**&#10;- Trong Service layer để lấy current user&#10;- Để filter data theo user (ví dụ: lấy cart của user hiện tại)&#10;&#10;**Ví dụ:**&#10;```java&#10;// Trong CartService&#10;public CartDTO getCartItems() {&#10;    String username = SecurityUtils.getCurrentUsername();  // ← Lấy username&#10;    &#10;    Users user = userRepository.findByUsername(username)&#10;        .orElseThrow(() -&gt; new ClientException(&quot;User not found&quot;));&#10;    &#10;    // Lấy cart của user này...&#10;}&#10;```&#10;&#10;---&#10;&#10;#### **2. Check Is Authenticated**&#10;&#10;```java&#10;public static boolean isAuthenticated() {&#10;    Authentication authentication = SecurityContextHolder&#10;        .getContext()&#10;        .getAuthentication();&#10;    &#10;    return authentication != null&#10;        &amp;&amp; authentication.isAuthenticated()&#10;        &amp;&amp; !authentication.getName().equals(&quot;anonymousUser&quot;);&#10;}&#10;```&#10;&#10;**Khi nào dùng:**&#10;- Để check user đã login chưa&#10;- Conditional logic based on authentication status&#10;&#10;**Ví dụ:**&#10;```java&#10;if (SecurityUtils.isAuthenticated()) {&#10;    // Hiển thị user profile&#10;} else {&#10;    // Redirect to login&#10;}&#10;```&#10;&#10;---&#10;&#10;#### **3. Get Authentication Object**&#10;&#10;```java&#10;public static Authentication getAuthentication() {&#10;    return SecurityContextHolder.getContext().getAuthentication();&#10;}&#10;```&#10;&#10;**Khi nào dùng:**&#10;- Khi cần toàn bộ Authentication object&#10;- Để lấy authorities/roles (nếu có)&#10;&#10;---&#10;&#10;### ** SECURITYCONTEXT FLOW:**&#10;&#10;```&#10;┌─────────────────────────────────────────────────────┐&#10;│  AuthTokenFilter (doFilterInternal)                 │&#10;│                                                     │&#10;│  Authentication auth = new                          │&#10;│    UsernamePasswordAuthenticationToken(             │&#10;│      username,      // &quot;john_doe&quot;                   │&#10;│      null,                                          │&#10;│      authorities    // []                           │&#10;│    );                                               │&#10;│                                                     │&#10;│  SecurityContextHolder.getContext()                 │&#10;│    .setAuthentication(auth);  ← SET AUTHENTICATION  │&#10;│                                                     │&#10;└────────────────┬────────────────────────────────────┘&#10;                 │ Thread-Local Storage&#10;                 ↓&#10;┌─────────────────────────────────────────────────────┐&#10;│  SecurityContext (Thread-Local)                     │&#10;│  ┌───────────────────────────────────────────────┐ │&#10;│  │ Authentication:                               │ │&#10;│  │  - Principal: &quot;john_doe&quot;                      │ │&#10;│  │  - Credentials: null                          │ │&#10;│  │  - Authorities: []                            │ │&#10;│  │  - Authenticated: true                        │ │&#10;│  └───────────────────────────────────────────────┘ │&#10;└────────────────┬────────────────────────────────────┘&#10;                 │ Available trong toàn bộ request&#10;                 ↓&#10;┌─────────────────────────────────────────────────────┐&#10;│  CartService.getCartItems()                         │&#10;│                                                     │&#10;│  String username =                                  │&#10;│    SecurityUtils.getCurrentUsername();              │&#10;│  // ← GET từ SecurityContext                       │&#10;│  // → &quot;john_doe&quot;                                    │&#10;│                                                     │&#10;│  Users user = userRepository                        │&#10;│    .findByUsername(username);  // Query DB          │&#10;│                                                     │&#10;└─────────────────────────────────────────────────────┘&#10;```&#10;&#10;---&#10;&#10;### ** TÓM TẮT SECURITYUTILS:**&#10;&#10;| Method | Return Type | Mục đích | Ví dụ |&#10;|--------|-------------|----------|-------|&#10;| `getCurrentUsername()` | String | Lấy username của user hiện tại | `&quot;john_doe&quot;` hoặc `null` |&#10;| `isAuthenticated()` | boolean | Check user đã login chưa | `true` hoặc `false` |&#10;| `getAuthentication()` | Authentication | Lấy toàn bộ Authentication object | Authentication object |&#10;&#10;---&#10;&#10;## 6. LUỒNG HOẠT ĐỘNG (FLOW)&#10;&#10;### ** COMPLETE REQUEST FLOW:**&#10;&#10;```&#10;┌─────────────────────────────────────────────────────────────────┐&#10;│  STEP 1: USER LOGIN                                             │&#10;└─────────────────────────────────────────────────────────────────┘&#10;&#10;Client (React):&#10;  POST /auth/login&#10;  Body: { username: &quot;john&quot;, password: &quot;pass123&quot; }&#10;  &#10;    ↓&#10;&#10;AuthController:&#10;  → UserService.login(request)&#10;  &#10;    ↓&#10;&#10;UserService:&#10;  1. Validate username &amp; password&#10;  2. jwtUtils.generateToken(&quot;john&quot;)  ← Generate JWT&#10;  3. Return LogInResponse { token: &quot;eyJhbGc...&quot; }&#10;  &#10;    ↓&#10;&#10;Client receives:&#10;  {&#10;    &quot;token&quot;: &quot;eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJqb2huIiwiaWF0...&quot;,&#10;    &quot;username&quot;: &quot;john&quot;,&#10;    &quot;name&quot;: &quot;John Doe&quot;&#10;  }&#10;  &#10;Client saves token:&#10;  localStorage.setItem('token', response.token)&#10;&#10;&#10;┌─────────────────────────────────────────────────────────────────┐&#10;│  STEP 2: SUBSEQUENT REQUESTS                                    │&#10;└─────────────────────────────────────────────────────────────────┘&#10;&#10;Client (React):&#10;  GET /cart&#10;  Headers: {&#10;    Authorization: Bearer eyJhbGciOiJIUzI1NiJ9...&#10;  }&#10;  &#10;    ↓&#10;&#10;┌───────────────────────────────────────────────────────────────┐&#10;│ WebSecurityConfig                                             │&#10;│  - Check endpoint: /cart → authenticated() required           │&#10;│  - CORS: Check origin = localhost:3000 → OK                   │&#10;└───────────────────┬───────────────────────────────────────────┘&#10;                    ↓&#10;&#10;┌───────────────────────────────────────────────────────────────┐&#10;│ AuthTokenFilter.doFilterInternal()                            │&#10;│                                                               │&#10;│  1. authHeader = &quot;Bearer eyJhbGc...&quot;                          │&#10;│  2. token = authHeader.substring(7) = &quot;eyJhbGc...&quot;            │&#10;│  3. username = jwtUtils.getUsernameFromJwtToken(token)        │&#10;│     → &quot;john&quot;                                                  │&#10;│  4. isValid = jwtUtils.validateToken(token)                   │&#10;│     → true                                                    │&#10;│  5. authentication = new UsernamePasswordAuthenticationToken( │&#10;│        &quot;john&quot;, null, []                                       │&#10;│     )                                                         │&#10;│  6. SecurityContextHolder.getContext()                        │&#10;│       .setAuthentication(authentication)                      │&#10;│                                                               │&#10;└───────────────────┬───────────────────────────────────────────┘&#10;                    ↓&#10;&#10;┌───────────────────────────────────────────────────────────────┐&#10;│ CartController.getMyCart()                                    │&#10;│  - Request reaches controller                                 │&#10;└───────────────────┬───────────────────────────────────────────┘&#10;                    ↓&#10;&#10;┌───────────────────────────────────────────────────────────────┐&#10;│ CartService.getCartItems()                                    │&#10;│                                                               │&#10;│  1. username = SecurityUtils.getCurrentUsername()             │&#10;│     → &quot;john&quot;  (from SecurityContext)                          │&#10;│                                                               │&#10;│  2. user = userRepository.findByUsername(&quot;john&quot;)              │&#10;│     → Users { id: 123, username: &quot;john&quot;, ... }                │&#10;│                                                               │&#10;│  3. cart = cartRepository.findByUserId(123)                   │&#10;│     → Cart { id: 456, userId: 123, ... }                      │&#10;│                                                               │&#10;│  4. Build CartDTO and return                                  │&#10;│                                                               │&#10;└───────────────────┬───────────────────────────────────────────┘&#10;                    ↓&#10;&#10;Response to Client:&#10;  {&#10;    &quot;cartId&quot;: 456,&#10;    &quot;totalQuantity&quot;: 3,&#10;    &quot;items&quot;: [...]&#10;  }&#10;```&#10;&#10;---&#10;&#10;### **❌ ERROR FLOW - Invalid Token:**&#10;&#10;```&#10;Client:&#10;  GET /cart&#10;  Headers: { Authorization: Bearer INVALID_TOKEN }&#10;  &#10;    ↓&#10;&#10;AuthTokenFilter:&#10;  1. token = &quot;INVALID_TOKEN&quot;&#10;  2. jwtUtils.validateToken(token)&#10;     → false (MalformedJwtException)&#10;  3. Authentication NOT SET&#10;  &#10;    ↓&#10;&#10;WebSecurityConfig:&#10;  - Endpoint /cart requires authenticated()&#10;  - SecurityContext.getAuthentication() = null&#10;  - ❌ REJECT REQUEST&#10;  &#10;    ↓&#10;&#10;Response to Client:&#10;  HTTP 401 Unauthorized&#10;  {&#10;    &quot;error&quot;: &quot;Unauthorized&quot;,&#10;    &quot;message&quot;: &quot;Full authentication is required&quot;&#10;  }&#10;```&#10;&#10;---&#10;&#10;## 7. USE CASES THỰC TẾ&#10;&#10;### **USE CASE 1: User Login**&#10;&#10;**Scenario:** User đăng nhập vào hệ thống&#10;&#10;**Code Flow:**&#10;```java&#10;// 1. Frontend gửi request&#10;POST /auth/login&#10;{&#10;  &quot;username&quot;: &quot;john_doe&quot;,&#10;  &quot;password&quot;: &quot;MyPassword123!&quot;&#10;}&#10;&#10;// 2. AuthController nhận request&#10;@PostMapping(&quot;/login&quot;)&#10;public ResponseEntity&lt;LogInResponse&gt; login(@RequestBody LogInRequest request) {&#10;    LogInResponse response = userServiceInterface.login(request);&#10;    return ResponseEntity.ok(response);&#10;}&#10;&#10;// 3. UserService xử lý&#10;public LogInResponse login(LogInRequest request) {&#10;    // 3.1. Tìm user&#10;    Users user = userRepository.findByUsername(request.getUsername())&#10;        .orElseThrow(() -&gt; new ClientException(&quot;User not found&quot;));&#10;    &#10;    // 3.2. Verify password&#10;    if (!passwordEncoder.matches(request.getPassword(), user.getPassword())) {&#10;        throw new ClientException(&quot;Invalid password&quot;);&#10;    }&#10;    &#10;    // 3.3. Generate JWT token&#10;    String token = jwtUtils.generateToken(user.getUsername());  // ← JwtUtils&#10;    &#10;    // 3.4. Return response&#10;    return LogInResponse.builder()&#10;        .token(token)&#10;        .username(user.getUsername())&#10;        .name(user.getName())&#10;        .build();&#10;}&#10;&#10;// 4. Frontend nhận token và lưu&#10;localStorage.setItem('token', response.token);&#10;```&#10;&#10;---&#10;&#10;### **USE CASE 2: Get User's Cart**&#10;&#10;**Scenario:** User đã login muốn xem giỏ hàng&#10;&#10;**Code Flow:**&#10;```java&#10;// 1. Frontend gửi request với token&#10;GET /cart&#10;Headers: {&#10;  Authorization: Bearer eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJqb2huX2RvZSI...&#10;}&#10;&#10;// 2. AuthTokenFilter intercept&#10;protected void doFilterInternal(...) {&#10;    String token = authHeader.substring(7);&#10;    String username = jwtUtils.getUsernameFromJwtToken(token);  // ← &quot;john_doe&quot;&#10;    &#10;    if (username != null &amp;&amp; jwtUtils.validateToken(token)) {&#10;        UsernamePasswordAuthenticationToken auth = &#10;            new UsernamePasswordAuthenticationToken(username, null, []);&#10;        SecurityContextHolder.getContext().setAuthentication(auth);&#10;    }&#10;    &#10;    filterChain.doFilter(request, response);&#10;}&#10;&#10;// 3. CartController nhận request&#10;@GetMapping&#10;public ResponseEntity&lt;CartDTO&gt; getMyCart() {&#10;    CartDTO cart = cartService.getCartItems();  // Không cần userId param!&#10;    return ResponseEntity.ok(cart);&#10;}&#10;&#10;// 4. CartService lấy cart&#10;public CartDTO getCartItems() {&#10;    // 4.1. Lấy username từ SecurityContext&#10;    String username = SecurityUtils.getCurrentUsername();  // ← &quot;john_doe&quot;&#10;    &#10;    if (username == null) {&#10;        throw new ClientException(&quot;User not authenticated&quot;);&#10;    }&#10;    &#10;    // 4.2. Lấy User từ username&#10;    Users user = userRepository.findByUsername(username)&#10;        .orElseThrow(() -&gt; new ServerException(&quot;User not found&quot;));&#10;    &#10;    // 4.3. Lấy Cart của user&#10;    Cart cart = cartRepository.findByUserId(user.getId())&#10;        .orElseThrow(() -&gt; new ServerException(&quot;Cart not found&quot;));&#10;    &#10;    // 4.4. Load cart items và return&#10;    // ... (N+1 problem đã fix)&#10;}&#10;```&#10;&#10;**✅ Lợi ích:**&#10;- Không cần gửi userId từ client (bảo mật)&#10;- Server tự động biết user nào đang request&#10;- Client không thể xem cart của người khác&#10;&#10;---&#10;&#10;### **USE CASE 3: Add Product to Cart**&#10;&#10;**Scenario:** User thêm sản phẩm vào giỏ hàng&#10;&#10;**Code Flow:**&#10;```java&#10;// 1. Frontend gửi request&#10;POST /cart/add&#10;Headers: { Authorization: Bearer &lt;token&gt; }&#10;Body: {&#10;  &quot;productId&quot;: 123,&#10;  &quot;quantity&quot;: 2&#10;}&#10;&#10;// 2. AuthTokenFilter → Set authentication (same as above)&#10;&#10;// 3. CartController&#10;@PostMapping(&quot;/add&quot;)&#10;public ResponseEntity&lt;String&gt; addToCart(@RequestBody Map&lt;String, Object&gt; payload) {&#10;    Long productId = Long.valueOf((Integer) payload.get(&quot;productId&quot;));&#10;    int quantity = (int) payload.get(&quot;quantity&quot;);&#10;    &#10;    String result = cartService.addProductToCart(productId, quantity);&#10;    return ResponseEntity.ok(result);&#10;}&#10;&#10;// 4. CartService&#10;public String addProductToCart(Long productId, int quantity) {&#10;    // 4.1. Lấy current user&#10;    String username = SecurityUtils.getCurrentUsername();  // ← From SecurityContext&#10;    Users user = userRepository.findByUsername(username)&#10;        .orElseThrow(() -&gt; new ServerException(&quot;User not found&quot;));&#10;    &#10;    // 4.2. Lấy cart của user&#10;    Cart cart = cartRepository.findByUserId(user.getId())&#10;        .orElseThrow(() -&gt; new ServerException(&quot;Cart not found&quot;));&#10;    &#10;    // 4.3. Check product tồn kho&#10;    Product product = productRepository.findById(productId)&#10;        .orElseThrow(() -&gt; new ServerException(&quot;Product not found&quot;));&#10;    &#10;    if (product.getQuantity() &lt; quantity) {&#10;        throw new ClientException(&quot;Not enough stock&quot;);&#10;    }&#10;    &#10;    // 4.4. Add to cart&#10;    CartDetail cartDetail = CartDetail.builder()&#10;        .cartId(cart.getId())&#10;        .productId(productId)&#10;        .quantity(quantity)&#10;        .build();&#10;    &#10;    cartDetailRepository.save(cartDetail);&#10;    return &quot;Item added successfully!&quot;;&#10;}&#10;```&#10;&#10;**✅ Security:**&#10;- User chỉ có thể add vào cart của mình&#10;- Không thể add vào cart của người khác&#10;- Server validate user từ JWT token&#10;&#10;---&#10;&#10;##  SO SÁNH: TRƯỚC &amp; SAU KHI DÙNG JWT&#10;&#10;### **❌ TRƯỚC (Không an toàn):**&#10;&#10;```java&#10;// Controller - Client gửi userId&#10;@GetMapping(&quot;/cart/{userId}&quot;)&#10;public CartDTO getCart(@PathVariable Long userId) {&#10;    return cartService.getCartItems(userId);  // ⚠️ NGUY HIỂM!&#10;}&#10;&#10;// Client có thể gửi bất kỳ userId nào:&#10;GET /cart/123  // Xem cart của user 123&#10;GET /cart/456  // Xem cart của user 456&#10;GET /cart/789  // Xem cart của user 789&#10;```&#10;&#10;**Vấn đề:**&#10;- ❌ Client có thể xem cart của người khác&#10;- ❌ Không có authentication&#10;- ❌ Không có authorization&#10;&#10;---&#10;&#10;### **✅ SAU (An toàn với JWT):**&#10;&#10;```java&#10;// Controller - Không cần userId&#10;@GetMapping(&quot;/cart&quot;)&#10;public CartDTO getMyCart() {&#10;    return cartService.getCartItems();  // ✅ AN TOÀN&#10;}&#10;&#10;// CartService - Lấy user từ JWT&#10;public CartDTO getCartItems() {&#10;    String username = SecurityUtils.getCurrentUsername();  // From JWT&#10;    Users user = userRepository.findByUsername(username);&#10;    Cart cart = cartRepository.findByUserId(user.getId());&#10;    // ...&#10;}&#10;&#10;// Client chỉ có thể xem cart của chính mình:&#10;GET /cart  (với JWT token của user A) → Cart của user A&#10;GET /cart  (với JWT token của user B) → Cart của user B&#10;```&#10;&#10;**Lợi ích:**&#10;- ✅ User chỉ xem được cart của mình&#10;- ✅ Server validate user từ JWT&#10;- ✅ Không thể giả mạo userId&#10;&#10;---&#10;&#10;##  KẾT LUẬN&#10;&#10;### **TÓM TẮT VAI TRÒ TỪNG COMPONENT:**&#10;&#10;| Component | Vai trò | Khi nào chạy |&#10;|-----------|---------|--------------|&#10;| **JwtUtils** | Generate, parse, validate JWT token | Login (generate), mỗi request (validate) |&#10;| **AuthTokenFilter** | Intercept request, parse token, set authentication | Mỗi HTTP request đến server |&#10;| **WebSecurityConfig** | Cấu hình security rules, CORS, password encoder | Application startup |&#10;| **SecurityUtils** | Helper để lấy current user | Trong Service layer khi cần user info |&#10;&#10;---&#10;&#10;### **WORKFLOW TỔNG THỂ:**&#10;&#10;```&#10;1. USER LOGIN&#10;   ↓&#10;   JwtUtils.generateToken() → Token&#10;   ↓&#10;   Client saves token&#10;&#10;2. USER REQUEST (với token)&#10;   ↓&#10;   AuthTokenFilter intercept&#10;   ↓&#10;   JwtUtils.validateToken() → Valid?&#10;   ↓&#10;   Set Authentication vào SecurityContext&#10;&#10;3. CONTROLLER/SERVICE&#10;   ↓&#10;   SecurityUtils.getCurrentUsername()&#10;   ↓&#10;   Get user info từ SecurityContext&#10;   ↓&#10;   Process business logic&#10;```&#10;&#10;---&#10;&#10;### **BEST PRACTICES:**&#10;&#10;1. ✅ **Luôn validate token** trong AuthTokenFilter&#10;2. ✅ **Không tin tưởng client data** (userId, email, etc.)&#10;3. ✅ **Lấy user từ JWT token** thay vì parameter&#10;4. ✅ **Dùng SecurityUtils** để get current user&#10;5. ✅ **STATELESS session** với JWT&#10;6. ✅ **CORS configuration** cho frontend&#10;7. ✅ **BCrypt password** encoding&#10;&#10;---&#10;&#10;### **SECURITY CHECKLIST:**&#10;&#10;- [x] JWT token signed với secret key&#10;- [x] Token có expiration time&#10;- [x] Token validate mỗi request&#10;- [x] CSRF disabled (dùng JWT)&#10;- [x] CORS configured properly&#10;- [x] Password hashed với BCrypt&#10;- [x] Stateless session (không dùng cookie)&#10;- [x] Authorization rules đúng (public/protected)&#10;&#10;---&#10;&#10;**Tác giả:** GitHub Copilot  &#10;**Version:** 1.0  &#10;**Cập nhật:** 2025-11-21&#10;&#10;---&#10;&#10;##  APPENDIX: Configuration Files&#10;&#10;### **application.properties**&#10;```properties&#10;# JWT Configuration&#10;JWT_SECRET=YourVeryLongSecretKeyThatIsAtLeast256BitsLongForHS256Algorithm&#10;JWT_EXPIRATION=86400000&#10;&#10;# Server Port&#10;server.port=8080&#10;&#10;# Database (if needed)&#10;spring.datasource.url=jdbc:postgresql://localhost:5432/salestech&#10;spring.datasource.username=postgres&#10;spring.datasource.password=password&#10;```&#10;&#10;### **Environment Variables (.env)**&#10;```bash&#10;JWT_SECRET=YourVeryLongSecretKeyThatIsAtLeast256BitsLongForHS256Algorithm&#10;JWT_EXPIRATION=86400000&#10;```&#10;&#10;---&#10;&#10;**END OF DOCUMENT**&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/FE/my-react-app/src/pages/homepage/Home_FINAL.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/FE/my-react-app/src/pages/homepage/Home_FINAL.js" />
              <option name="updatedContent" value="import React, {useEffect, useState} from 'react';&#10;import '../../App.scss';&#10;import './Home.scss';&#10;import 'react-toastify/dist/ReactToastify.css';&#10;import ProductGrid from &quot;../../components/productgrid/ProductGrid&quot;;&#10;import Nav from &quot;../../components/navigation/Nav&quot;;&#10;import Header from &quot;../../components/header/Header&quot;;&#10;import FilterSidebar from &quot;../../components/filtersidebar/FilterSidebar&quot;;&#10;import useFetchProducts, { filterProducts, searchProducts } from &quot;../../api/ProductAPI&quot;;&#10;import {getCartItems} from &quot;../../api/CartAPI&quot;;&#10;&#10;function Home() {&#10;    const {products: allProducts, loading: initialLoading, error: initialError} = useFetchProducts();&#10;    const [count, setCount] = useState(0);&#10;    const {totalQuantity} = getCartItems();&#10;&#10;    // State for filtering&#10;    const [selectedCategoryId, setSelectedCategoryId] = useState(null);&#10;    const [selectedCategoryName, setSelectedCategoryName] = useState('');&#10;    const [products, setProducts] = useState([]);&#10;    const [loading, setLoading] = useState(false);&#10;    const [error, setError] = useState(null);&#10;&#10;    useEffect(() =&gt; {&#10;        setCount(totalQuantity);&#10;    }, [totalQuantity]);&#10;&#10;    // Load all products initially&#10;    useEffect(() =&gt; {&#10;        if (!initialLoading &amp;&amp; allProducts) {&#10;            setProducts(allProducts);&#10;        }&#10;    }, [allProducts, initialLoading]);&#10;&#10;    // Handle category change&#10;    const handleCategoryChange = async (categoryId) =&gt; {&#10;        setSelectedCategoryId(categoryId);&#10;        setError(null);&#10;&#10;        if (!categoryId) {&#10;            // Show all products&#10;            setProducts(allProducts);&#10;            setSelectedCategoryName('');&#10;            return;&#10;        }&#10;&#10;        setLoading(true);&#10;        try {&#10;            const filtered = await filterProducts(categoryId, {});&#10;            setProducts(filtered);&#10;            &#10;            // Get category name from CATEGORIES&#10;            const categoryNames = {&#10;                1: 'Máy tính xách tay',&#10;                2: 'Điện thoại di động',&#10;                3: 'Phụ kiện'&#10;            };&#10;            setSelectedCategoryName(categoryNames[categoryId] || '');&#10;        } catch (err) {&#10;            setError('Không thể tải sản phẩm');&#10;            console.error(err);&#10;        } finally {&#10;            setLoading(false);&#10;        }&#10;    };&#10;&#10;    // Handle filter change from sidebar&#10;    const handleFilterChange = async (filters) =&gt; {&#10;        if (!selectedCategoryId) return;&#10;&#10;        setLoading(true);&#10;        setError(null);&#10;        try {&#10;            const filtered = await filterProducts(selectedCategoryId, filters);&#10;            setProducts(filtered);&#10;        } catch (err) {&#10;            setError('Không thể lọc sản phẩm');&#10;            console.error(err);&#10;        } finally {&#10;            setLoading(false);&#10;        }&#10;    };&#10;&#10;    // Handle search&#10;    const handleSearch = async (keyword) =&gt; {&#10;        if (!keyword || keyword.trim() === '') {&#10;            // Reset to current view&#10;            if (selectedCategoryId) {&#10;                handleCategoryChange(selectedCategoryId);&#10;            } else {&#10;                setProducts(allProducts);&#10;            }&#10;            return;&#10;        }&#10;&#10;        setLoading(true);&#10;        setError(null);&#10;        try {&#10;            const results = await searchProducts(keyword);&#10;            setProducts(results);&#10;            setSelectedCategoryId(null); // Clear category when searching&#10;        } catch (err) {&#10;            setError('Không thể tìm kiếm sản phẩm');&#10;            console.error(err);&#10;        } finally {&#10;            setLoading(false);&#10;        }&#10;    };&#10;&#10;    if (initialLoading) return &lt;div className=&quot;loading-container&quot;&gt;&lt;p&gt;Đang tải sản phẩm...&lt;/p&gt;&lt;/div&gt;;&#10;    if (initialError) return &lt;div className=&quot;error-container&quot;&gt;&lt;p&gt;{initialError}&lt;/p&gt;&lt;/div&gt;;&#10;&#10;    return (&#10;        &lt;div className={&quot;MyApp&quot;}&gt;&#10;            &lt;Nav count={count}/&gt;&#10;&#10;            &lt;Header&#10;                title=&quot;Product&quot;&#10;                onSearch={handleSearch}&#10;                selectedCategoryId={selectedCategoryId}&#10;                onCategoryChange={handleCategoryChange}&#10;                modeDisplay={&quot;product&quot;}&#10;            /&gt;&#10;&#10;            &lt;div className=&quot;home-content&quot;&gt;&#10;                {/* Sidebar Filter - Only show when category is selected */}&#10;                {selectedCategoryId &amp;&amp; (&#10;                    &lt;div className=&quot;sidebar-container&quot;&gt;&#10;                        &lt;FilterSidebar&#10;                            categoryId={selectedCategoryId}&#10;                            categoryName={selectedCategoryName}&#10;                            onFilterChange={handleFilterChange}&#10;                        /&gt;&#10;                    &lt;/div&gt;&#10;                )}&#10;&#10;                {/* Product Grid */}&#10;                &lt;div className={`products-container ${selectedCategoryId ? 'with-sidebar' : 'full-width'}`}&gt;&#10;                    {loading &amp;&amp; &lt;div className=&quot;loading-overlay&quot;&gt;Đang tải...&lt;/div&gt;}&#10;                    {error &amp;&amp; &lt;div className=&quot;error-message&quot;&gt;{error}&lt;/div&gt;}&#10;                    &lt;ProductGrid products={products} count={setCount}/&gt;&#10;                &lt;/div&gt;&#10;            &lt;/div&gt;&#10;        &lt;/div&gt;&#10;    );&#10;}&#10;&#10;export default Home&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>